# 寫測試要從需求出發

[悟] TDD 的第一個步驟其實不要講成「先寫測試」，而是「先用程式碼描述需求的情境，讓需求可以被自動驗證。」
不知道有沒有更精準的說法？等悟得下一階段再想想看。

---

Demo Fan ：『如果有「寫一支 method，要從測試開始寫，麻煩麻煩」這樣的念頭，就表示你寫的不是TDD，你只是開始寫UT，然後把UT放在前面，測試案例裡面應該要可以描述需求，我要完成什麼事情所以我會這樣寫程式，測試寫完以後production code 應該也寫完了，測試方法就是怎麼使用API的Help page。
因為你現在只是把UT放到前面來寫，所以導致你很容易打結，你的腦袋一邊在寫怎麼寫 Production code 一邊在想怎麼打趴自己...』
我非常喜歡這段說明！完完全全把很多開發者對 TDD 的誤解表露無遺！尤其是：「因為你現在只是把UT放到前面來寫，所以導致你很容易打結，你的腦袋一邊在寫怎麼寫 Production code 一邊在想怎麼打趴自己」是很多開發者在剛接觸 TDD 時會幹的事 (以前的我就是其中之一) 。

---

單元測試

圖解：固定其他變因，只測試在乎的邏輯

斷線，亂數，圍繞著待測邏輯

驗證需求，而不是測試邏輯

a + b 是邏輯，商品有幾個是需求

---

有些時候，你意識到該為寫完的程式碼補上測試了；但為了測試到所有的程式碼，你又對程式動手腳，讓一堆原本不該被外界得知的細節，全部公開出來給測試程式驗證。
這是一個非常有問題的觀念，這樣或許能保證你做對了每個細節，也能夠讓測試涵蓋率 (code coverage) 得到很高的分數，但你只是在欠另一個技術債：讓往後接手的人不容易從測試看到全貌。因為他們不知道這些測試背後真正的目的是什麼，他們只看到一個又一個的方法被測試了。他們只覺得維護這些測試又是一次工，超級麻煩。
所以不要為了測試而測試，要先理解你的需求，想清楚它們可能會有什麼情境，而這些情境可能會有什麼樣的結果；這麼一來，寫出來的測試就有描述需求的能力，而得到的涵蓋率才會有它的意義存在，讓你可以發現到底還有什麼跟需求有關的主要邏輯是沒測到的，或是哪些程式碼其實是沒有必要的。
不要盲目追求 100% 的涵蓋率，要追求的是你確實驗證了程式滿足了需求以及處理了已經發生的問題。測試是一種描述需求的方式，只是剛好可以被自動執行。它們會帶你看到這個系統背後的需求，以及曾經發生過什麼樣的問題；讓你能在深入程式碼細節之前，就掌握了系統的全貌。
像是同事在對我的程式碼 code review 之前，他先看了我的測試，針對需求來瞭解我的程式已經驗證了哪些情境；在還沒有看到元件之間是怎麼搭配運作之前，他就已經透過測試明白每個元件的職責。接下來在深入程式核心時，他才對一些較為細微的部份給我建議，而不會一開始就掉入細節中，不知道為什麼我要這麼設計這些元件。
學會用測試去描述需求，是寫測試最基本卻也是重要的一課。


# 需求驅動測試涵蓋率

有意義的測試你才會有維護它的動力，而且通常你會先跑過它來確認這個系統是為了什麼需求而開發，而不是它能做些什麼。

當然這樣的習慣不容易養成，事實上就連我自己有時也會忘記要先跑測試再改程式。

不要只測試函式的正確與否，而是要描述為什麼會需要它？它會在哪些情境下處理什麼問題。

Code Review 三原則 ASK


---

當測試寫得越多的時候，越能感受到一個好的測試案例該描述些什麼。當然我也還不敢說自己的測試能寫得多好，但也漸漸達到「當回頭看自己測試時會發現描述不夠清楚」的境界。

有些 arrangement 跟待測需求無關，但又是必要時，我會將它放在 setUp 中，或直接抽離成新的方法供測試案例呼叫。但有些 arrangement  則是關乎著能否清楚表達待測需求所需要的資訊，這時候即使有重複性，我也會儘可能將它放在測試案例裡，而不會透過 DRY 原則將它藏起來。

而 unit 的定義也越來越能夠體會了，它有時候是指單一個 method ，有時是指好幾個 method 的組合；重要的是 unit 指的就是一件事，這件事就是需求中的某個狀況 (或稱情境) 。這個類別或這個方法是為了什麼需求而存在，它應該做到哪些事？它應該不能做哪些事？這些就會在一個一個的測試案例裡被描述出來。

而 assertion 也關乎著我們是否理解了這個需求真的要的是什麼？有時候錯誤的 assertion 只會擾亂我們對這個需求的理解，變成只為了驗證方法的正確性而存在，而不是驗證這個情境應該有什麼結果。這兩者的差別，真的需要花點時間增加經驗後才能體會。

也許寫測試是多花了一點時間，但每當程式能正確無誤跟其他程式共同合作時，你就會瞭解寫出這些有意義的測試絕對是值得的。

---

雖然自己不是什麼厲害的咖，但還是想聊一下自己對 TDD 的想法：會討厭 TDD 的人其實有很大的原因是他們把 TDD 用錯地方了。

我個人認為目前在談論的 TDD 其實適合用在 library / framework 的開發上，而非一般我們採用 Framework 來快速達成某個目標的專案上。因為這時 TDD 的 Test 多數人都認為它是 Unit Testing ，所以就想盡辦法讓 Model / View / Controller 的測試是獨立而不相依於其他環境，結果除了要寫一堆 Mock Object 外，還得面對 Test Case 自身的 bug 。

丟掉這個想法吧，廣義來說，這裡的 Test-driven 其實沒有一定要你做 Unit Testing ，而是測試你的系統業務邏輯。舉例來說，當你的 ORM framework 已經被自己的測試驗證過了，你就大可不必再去針對那些 CRUD 做測試。你該測試的其實是：資料庫無法連接時系統該做的反應是否正常，或是我們針對資料取出後或寫入前的業務邏輯是否正確。

換句話說，專案的測試案例應該關注的是系統抽象邏輯，而不是 library API 的層級，這也就是為什麼 BDD 後來會被提出的原因之一。

另外「測試先行」這個行為不見得適合每一種狀況，如果你不能掌握它的理念，那麼就暫時不要這麼做；因為沒有目標來寫測試，只會讓你越加討厭先寫測試。但寫測試這件事還是必要的，當你越來越瞭解自己在做什麼的時候，你才能體會到寫測試的好處；然後你會在某個時機點驚覺：為什麼我不在專案一開始就先寫好測試呢？

不要聽了那些大師們對 TDD 的批判後，就覺得它不過是名詞而已；那就像你遇到政治問題就直接把它打成是藍綠問題一樣的道理。真的去瞭解測試的本質是要為你做什麼，而不是只是為了想要有測試而寫測試，或是為了反對 TDD 擁護者而不想先寫測試。

最後再強調一點： TDD 是幫你實現專案的工具之一，該不該用，該怎麼用，只有通過專案的歷練才會讓你瞭然於心。

夜深想睡了，觀念不正確或是有詞不達意的部份還請大家多多指教與包涵。

---

測試 native function 的組合必要嗎？

先前分享 TDD 時，有朋友問到：只是 native functions 的組合需要測試嗎？

例如：

fetch: function () {
  return JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]')
}

總覺得當時的回答還不夠精準，這裡補充一下。

這問題其實要反過來看，因為先對規格寫好測試，我們才發現用 native funtion 組合就可以達到我們的需求。

---

本文描述了一個有七年歷史也有自動化測試的 legacy code ，為什麼還是有維護與發佈上的問題。原因是測試沒有抓到重點，而 UI 測試沒有適時更新。實務上應該是越上層的測試要越貼近規格，而非實作細節。

http://www.infoq.com/cn/articles/automation-test-of-a-seven-year-legacy-system

